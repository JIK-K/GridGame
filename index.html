<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GridGame</title>
    <style>
      .grid-game {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        grid-template-rows: repeat(6, 1fr);
        width: 300px;
        height: 300px;
        position: relative;
        align-self: center;
      }

      .cell {
        background-color: black;
        border: 1px solid white; /* 셀 사이의 간격을 만들기 위한 테두리 설정 */
        position: relative; /* 자식 요소의 위치 설정을 위한 상대적 위치 설정 */
      }

      .cell.white {
        background-color: white;
      }

      .cell.blue {
        background-color: blue;
      }

      .custom-content {
        position: absolute; /* 절대 위치 설정 */
        top: 50%; /* 부모 요소 상단으로부터 50% 위치 */
        left: 50%; /* 부모 요소 왼쪽으로부터 50% 위치 */
        transform: translate(
          -50%,
          -50%
        ); /* 수평 및 수직으로 50% 이동하여 정확한 중앙 위치 설정 */
        background-color: green;
        width: 40px; /* 원하는 크기로 조절하세요 */
        height: 40px; /* 원하는 크기로 조절하세요 */
        cursor: pointer; /* 마우스 커서를 포인터로 변경하여 클릭 가능한 요소임을 표시 */
      }

      .highlighted {
        background-color: lightblue; /* 강조된 셀의 배경색 */
      }

      .arrows {
        position: relative;
        /* bottom: 20px; */
        padding: 10px;
        width: 300px;
        left: 50%;
        transform: translateX(-50%);
        display: flex; /* 방향키를 가로로 배치하기 위해 추가 */
      }

      .arrow {
        width: 40px;
        height: 40px;
        background-color: rgba(0, 255, 0, 0.5);
        cursor: pointer;
        margin: 0 5px;
      }
    </style>
  </head>
  <body>
    <div style="display: flex; flex-direction: column">
      <div class="grid-game" id="gridGame"></div>

      <div class="arrows">
        <div class="arrow up" onclick="moveGreenCell('up')">&#8593;</div>
        <div class="arrow down" onclick="moveGreenCell('down')">&#8595;</div>
        <div class="arrow left" onclick="moveGreenCell('left')">&#8592;</div>
        <div class="arrow right" onclick="moveGreenCell('right')">&#8594;</div>
      </div>
      <div
        style="
          display: flex;
          flex-direction: columns;
          align-self: center;
          padding: 10px;
        "
      >
        <ol>
          <li>
            모든 <span style="color: green; font-weight: bold">초록색</span>을
            <span style="color: blue; font-weight: bold">파란색</span>위에
            위치시키면 게임종료.
          </li>
          <li>
            <span style="color: green; font-weight: bold">초록색</span>을
            클릭하고 아래 방향키로 움직일 수 있다.
          </li>
          <li>
            <span style="color: green; font-weight: bold">초록색</span>은 흰색과
            초록색으로는 이동할 수 없다.
          </li>
          <li>
            <span style="color: green; font-weight: bold">초록색</span>을
            움직일때 뒷공간에 자리가 없으면 움직일 수 없다.
          </li>
        </ol>
      </div>
    </div>

    <script>
      let selectedGreenCell = null;

      // 그리드를 만들기 위한 함수
      function createGrid(rows, cols) {
        const gridGame = document.getElementById("gridGame");
        const gridSize = rows * cols;

        // 셀 생성
        for (let i = 0; i < gridSize; i++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          gridGame.appendChild(cell);
        }

        const whitePositions = [
          [1, 1],
          [1, 2],
          [1, 5],
          [1, 6],
          [2, 1],
          [2, 2],
          [2, 6],
          [4, 2],
          [5, 4],
          [5, 6],
          [6, 1],
          [6, 2],
          [6, 6],
        ];

        const bluePositions = [
          [2, 4],
          [3, 1],
          [3, 4],
          [3, 5],
        ];

        // 초록색 셀 생성 및 지정된 위치에 배치
        const greenPositions = [
          [3, 2],
          [3, 3],
          [5, 3],
          [5, 5],
        ];
        greenPositions.forEach((pos) => {
          const greenCell = document.createElement("div");
          greenCell.classList.add("custom-content");
          gridGame.appendChild(greenCell);
          placeGreenCell(greenCell, pos[0], pos[1]);
        });

        // 하얀색 배경 셀 추가
        whitePositions.forEach((pos) => {
          const index = (pos[0] - 1) * cols + (pos[1] - 1);
          const whiteCell = gridGame.children[index];
          whiteCell.classList.add("white");
        });

        // 파란색 배경 셀 추가
        bluePositions.forEach((pos) => {
          const index = (pos[0] - 1) * cols + (pos[1] - 1);
          const blueCell = gridGame.children[index];
          blueCell.classList.add("blue");
        });

        // 초록색 셀 클릭 시 이벤트 처리
        document.querySelectorAll(".custom-content").forEach((item) => {
          item.addEventListener("click", (event) => {
            // 클릭한 초록색 셀을 선택하고 표시
            selectedGreenCell = event.target;
            document.querySelectorAll(".custom-content").forEach((item) => {
              item.classList.remove("highlighted");
            });
            selectedGreenCell.classList.add("highlighted");
          });
        });
      }

      // 초록색 셀을 특정 위치에 배치하는 함수
      function placeGreenCell(greenCell, row, col) {
        const index = (row - 1) * 6 + (col - 1);
        gridGame.children[index].appendChild(greenCell);
      }

      // 초록색 셀을 이동시키는 함수
      function moveGreenCell(direction) {
        if (!selectedGreenCell) return;

        const parentCell = selectedGreenCell.parentElement;
        const rows = 6; // 그리드 행 수
        const cols = 6; // 그리드 열 수
        const currentIndex = Array.from(
          parentCell.parentElement.children
        ).indexOf(parentCell);
        let newIndex;

        // 이동 방향에 따라 새로운 인덱스 계산
        switch (direction) {
          case "up":
            newIndex = currentIndex - cols;
            break;
          case "down":
            newIndex = currentIndex + cols;
            break;
          case "left":
            newIndex = currentIndex - 1;
            break;
          case "right":
            newIndex = currentIndex + 1;
            break;
          default:
            return;
        }

        // 새로운 인덱스의 반대 방향에 흰색 또는 초록색이 있는지 확인
        const oppositeIndex = getOppositeIndex(currentIndex, direction);
        const oppositeCell = parentCell.parentElement.children[oppositeIndex];
        const oppositeCellContent =
          oppositeCell.querySelector(".custom-content");

        // 반대 방향에 흰색 또는 초록색이 있는 경우 이동 불가
        if (oppositeCell.classList.contains("white") || oppositeCellContent) {
          return;
        }

        // 새로운 인덱스가 유효한지 확인하고 유효할 경우 이동
        if (
          newIndex >= 0 &&
          newIndex < rows * cols &&
          !(currentIndex % cols === 0 && direction === "left") &&
          !((currentIndex + 1) % cols === 0 && direction === "right")
        ) {
          const targetCell = parentCell.parentElement.children[newIndex];
          if (
            targetCell.classList.contains("white") ||
            targetCell.querySelector(".custom-content")
          ) {
            return; // 흰색이나 초록색 셀로는 이동할 수 없음
          }
          parentCell.removeChild(selectedGreenCell);
          targetCell.appendChild(selectedGreenCell);

          // 클리어 조건 확인
          checkClear();
        }
      }

      // 클리어 조건 확인 함수
      function checkClear() {
        const blueCells = document.querySelectorAll(".blue");
        let greenCount = 0;
        blueCells.forEach((blueCell) => {
          if (blueCell.querySelector(".custom-content")) {
            greenCount++;
          }
        });

        if (greenCount === 4) {
          alert("클리어!");
        }
      }

      // 이동 방향에 따른 반대 방향의 인덱스를 계산하는 함수
      function getOppositeIndex(currentIndex, direction) {
        const cols = 6; // 그리드 열 수
        switch (direction) {
          case "up":
            return currentIndex + cols;
          case "down":
            return currentIndex - cols;
          case "left":
            return currentIndex + 1;
          case "right":
            return currentIndex - 1;
          default:
            return -1;
        }
      }

      // 그리드 생성
      createGrid(6, 6);
    </script>
  </body>
</html>
